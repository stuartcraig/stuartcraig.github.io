<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Underwater Adventure - Hard Mode</title>
    <script src="fishrun/3.4.16"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        .game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(180deg, #005a87 0%, #001220 100%);
            overflow: hidden;
        }
        
        .fish {
            position: absolute;
            width: 60px;
            height: 40px;
            z-index: 10;
            will-change: transform;
        }
        
        .obstacle {
            position: absolute;
            z-index: 5;
        }
        
        .seaweed {
            position: absolute;
            bottom: 0;
            z-index: 2;
        }
        
        .bubble {
            position: absolute;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.4);
            animation: float 5s infinite ease-in-out;
            z-index: 1;
        }
        
        @keyframes float {
            0% { transform: translateY(0) translateX(0); }
            50% { transform: translateY(-20px) translateX(5px); }
            100% { transform: translateY(0) translateX(0); }
        }
        
        .game-over {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 2rem;
            border-radius: 1rem;
            text-align: center;
            z-index: 20;
        }
        
        .score-display {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-size: 1.2rem;
            z-index: 20;
        }
        
        .difficulty-display {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background: rgba(139, 0, 0, 0.7);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-size: 1.2rem;
            z-index: 20;
        }
        
        .start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 18, 32, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 30;
        }
        
        .btn {
            background: #00a8ff;
            color: white;
            border: none;
            padding: 0.8rem 2rem;
            font-size: 1.2rem;
            border-radius: 2rem;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 1rem;
        }
        
        .btn:hover {
            background: #0088cc;
            transform: scale(1.05);
        }
        
        .sand {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 10%;
            background: linear-gradient(180deg, #d2b48c 0%, #8b4513 100%);
            z-index: 1;
        }
        
        .warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.3);
            color: white;
            padding: 1rem 2rem;
            border-radius: 0.5rem;
            font-size: 1.5rem;
            z-index: 15;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        /* Debug hitbox visualization (only visible when debug mode is on) */
        .hitbox {
            position: absolute;
            border: 2px solid red;
            background-color: rgba(255, 0, 0, 0.2);
            pointer-events: none;
            z-index: 100;
            display: none;
        }
    </style>
<style>*, ::before, ::after{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / 0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / 0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }/* ! tailwindcss v3.4.16 | MIT License | https://tailwindcss.com */*,::after,::before{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}::after,::before{--tw-content:''}:host,html{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4;font-family:ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]:where(:not([hidden=until-found])){display:none}.mb-4{margin-bottom:1rem}.mb-6{margin-bottom:1.5rem}.bg-blue-900{--tw-bg-opacity:1;background-color:rgb(30 58 138 / var(--tw-bg-opacity, 1))}.text-2xl{font-size:1.5rem;line-height:2rem}.text-3xl{font-size:1.875rem;line-height:2.25rem}.text-4xl{font-size:2.25rem;line-height:2.5rem}.text-xl{font-size:1.25rem;line-height:1.75rem}.font-bold{font-weight:700}.text-red-500{--tw-text-opacity:1;color:rgb(239 68 68 / var(--tw-text-opacity, 1))}.text-white{--tw-text-opacity:1;color:rgb(255 255 255 / var(--tw-text-opacity, 1))}</style></head>
<body class="bg-blue-900">
    <div class="game-container" id="gameContainer">
        <div class="score-display" id="scoreDisplay">Score: 0</div>
        <div class="difficulty-display" id="difficultyDisplay">HARD MODE</div>
        
        <div class="warning" id="warning">DANGER!</div>
        
        <div class="start-screen" id="startScreen">
            <h1 class="text-4xl font-bold text-white mb-4">Underwater Adventure</h1>
            <h2 class="text-2xl font-bold text-red-500 mb-4">HARD MODE</h2>
            <p class="text-xl text-white mb-6">Survive if you can!</p>
            <p class="text-white mb-4">Use arrow keys or tap/click to move</p>
            <button class="btn" id="startButton">Start Game</button>
        </div>
        
        <div class="game-over" id="gameOver">
            <h2 class="text-3xl font-bold mb-4">Game Over!</h2>
            <p class="text-xl mb-4">Your score: <span id="finalScore">0</span></p>
            <button class="btn" id="restartButton">Try Again</button>
        </div>
        
        <div class="sand"></div>
        
        <!-- Debug hitbox container -->
        <div id="fishHitbox" class="hitbox"></div>
    <div class="bubble" style="width: 12.0486px; height: 12.0486px; left: 249.01px; top: 717.865px; animation-delay: 3.22295s;"></div><div class="bubble" style="width: 6.1001px; height: 6.1001px; left: 218.912px; top: 743.989px; animation-delay: 0.793248s;"></div><div class="bubble" style="width: 20.9551px; height: 20.9551px; left: 655.461px; top: 157.191px; animation-delay: 0.484889s;"></div><div class="bubble" style="width: 18.0944px; height: 18.0944px; left: 567.121px; top: 351.145px; animation-delay: 4.65415s;"></div><div class="bubble" style="width: 14.0634px; height: 14.0634px; left: 49.6559px; top: 402.442px; animation-delay: 3.84468s;"></div><div class="bubble" style="width: 8.81226px; height: 8.81226px; left: 318.308px; top: 755.506px; animation-delay: 1.05669s;"></div><div class="bubble" style="width: 11.2692px; height: 11.2692px; left: 829.681px; top: 383.199px; animation-delay: 2.6101s;"></div><div class="bubble" style="width: 5.83634px; height: 5.83634px; left: 99.9892px; top: 693.115px; animation-delay: 3.04542s;"></div><div class="bubble" style="width: 13.8955px; height: 13.8955px; left: 783.364px; top: 1.2231px; animation-delay: 1.31349s;"></div><div class="bubble" style="width: 22.2436px; height: 22.2436px; left: 373.943px; top: 40.3322px; animation-delay: 3.30324s;"></div><div class="bubble" style="width: 8.75687px; height: 8.75687px; left: 479.044px; top: 428.806px; animation-delay: 0.675594s;"></div><div class="bubble" style="width: 21.2271px; height: 21.2271px; left: 407.109px; top: 641.692px; animation-delay: 0.880578s;"></div><div class="bubble" style="width: 10.6145px; height: 10.6145px; left: 847.678px; top: 591.199px; animation-delay: 3.48978s;"></div><div class="bubble" style="width: 15.8545px; height: 15.8545px; left: 739.779px; top: 387.869px; animation-delay: 1.53207s;"></div><div class="bubble" style="width: 7.30693px; height: 7.30693px; left: 542.289px; top: 235.986px; animation-delay: 2.16645s;"></div><div class="bubble" style="width: 13.09px; height: 13.09px; left: 348.216px; top: 318.047px; animation-delay: 1.19427s;"></div><div class="bubble" style="width: 20.1408px; height: 20.1408px; left: 882.449px; top: 111.562px; animation-delay: 1.4313s;"></div><div class="bubble" style="width: 7.60026px; height: 7.60026px; left: 722.819px; top: 48.8292px; animation-delay: 1.162s;"></div><div class="bubble" style="width: 20.2509px; height: 20.2509px; left: 61.2647px; top: 443.828px; animation-delay: 3.60574s;"></div><div class="bubble" style="width: 13.4456px; height: 13.4456px; left: 515.014px; top: 186.644px; animation-delay: 0.753766s;"></div><div class="seaweed" style="left: 0px;">
                        <svg width="30" height="142.16945115382595" viewBox="0 0 30 142.16945115382595" xmlns="http://www.w3.org/2000/svg">
                            <path d="M15,0 C10,42.65083534614778 20,71.08472557691297 15,142.16945115382595 M5,0 C0,56.86778046153038 10,85.30167069229556 5,142.16945115382595 M25,0 C20,28.43389023076519 30,99.51861580767816 25,142.16945115382595" stroke="#0a5c36" stroke-width="3" fill="none"></path>
                        </svg>
                    </div><div class="seaweed" style="left: 132px;">
                        <svg width="30" height="113.12598007867854" viewBox="0 0 30 113.12598007867854" xmlns="http://www.w3.org/2000/svg">
                            <path d="M15,0 C10,33.93779402360356 20,56.56299003933927 15,113.12598007867854 M5,0 C0,45.25039203147142 10,67.87558804720712 5,113.12598007867854 M25,0 C20,22.62519601573571 30,79.18818605507496 25,113.12598007867854" stroke="#0a5c36" stroke-width="3" fill="none"></path>
                        </svg>
                    </div><div class="seaweed" style="left: 264px;">
                        <svg width="30" height="126.16242271581461" viewBox="0 0 30 126.16242271581461" xmlns="http://www.w3.org/2000/svg">
                            <path d="M15,0 C10,37.84872681474438 20,63.08121135790731 15,126.16242271581461 M5,0 C0,50.46496908632585 10,75.69745362948876 5,126.16242271581461 M25,0 C20,25.232484543162926 30,88.31369590107022 25,126.16242271581461" stroke="#0a5c36" stroke-width="3" fill="none"></path>
                        </svg>
                    </div><div class="seaweed" style="left: 396px;">
                        <svg width="30" height="59.034141339043586" viewBox="0 0 30 59.034141339043586" xmlns="http://www.w3.org/2000/svg">
                            <path d="M15,0 C10,17.710242401713074 20,29.517070669521793 15,59.034141339043586 M5,0 C0,23.613656535617437 10,35.42048480342615 5,59.034141339043586 M25,0 C20,11.806828267808719 30,41.323898937330505 25,59.034141339043586" stroke="#0a5c36" stroke-width="3" fill="none"></path>
                        </svg>
                    </div><div class="seaweed" style="left: 528px;">
                        <svg width="30" height="66.4006147250888" viewBox="0 0 30 66.4006147250888" xmlns="http://www.w3.org/2000/svg">
                            <path d="M15,0 C10,19.920184417526638 20,33.2003073625444 15,66.4006147250888 M5,0 C0,26.56024589003552 10,39.840368835053276 5,66.4006147250888 M25,0 C20,13.28012294501776 30,46.48043030756216 25,66.4006147250888" stroke="#0a5c36" stroke-width="3" fill="none"></path>
                        </svg>
                    </div><div class="seaweed" style="left: 660px;">
                        <svg width="30" height="127.22097222091328" viewBox="0 0 30 127.22097222091328" xmlns="http://www.w3.org/2000/svg">
                            <path d="M15,0 C10,38.166291666273985 20,63.61048611045664 15,127.22097222091328 M5,0 C0,50.88838888836531 10,76.33258333254797 5,127.22097222091328 M25,0 C20,25.444194444182656 30,89.05468055463929 25,127.22097222091328" stroke="#0a5c36" stroke-width="3" fill="none"></path>
                        </svg>
                    </div><div class="seaweed" style="left: 792px;">
                        <svg width="30" height="138.6626490226492" viewBox="0 0 30 138.6626490226492" xmlns="http://www.w3.org/2000/svg">
                            <path d="M15,0 C10,41.598794706794756 20,69.3313245113246 15,138.6626490226492 M5,0 C0,55.46505960905968 10,83.19758941358951 5,138.6626490226492 M25,0 C20,27.73252980452984 30,97.06385431585443 25,138.6626490226492" stroke="#0a5c36" stroke-width="3" fill="none"></path>
                        </svg>
                    </div><div class="seaweed" style="left: 924px;">
                        <svg width="30" height="120.76443581888444" viewBox="0 0 30 120.76443581888444" xmlns="http://www.w3.org/2000/svg">
                            <path d="M15,0 C10,36.22933074566533 20,60.38221790944222 15,120.76443581888444 M5,0 C0,48.30577432755378 10,72.45866149133066 5,120.76443581888444 M25,0 C20,24.15288716377689 30,84.5351050732191 25,120.76443581888444" stroke="#0a5c36" stroke-width="3" fill="none"></path>
                        </svg>
                    </div></div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const gameContainer = document.getElementById('gameContainer');
            const scoreDisplay = document.getElementById('scoreDisplay');
            const startScreen = document.getElementById('startScreen');
            const startButton = document.getElementById('startButton');
            const gameOverScreen = document.getElementById('gameOver');
            const restartButton = document.getElementById('restartButton');
            const finalScoreDisplay = document.getElementById('finalScore');
            const warningElement = document.getElementById('warning');
            const fishHitboxElement = document.getElementById('fishHitbox');
            
            let fish;
            let gameRunning = false;
            let score = 0;
            let obstacles = [];
            let animationId;
            let lastObstacleTime = 0;
            let obstacleInterval = 800;
            let gameSpeed = 8;
            let specialAttackTimer = 0;
            let currentLevel = 1;
            let isInvulnerable = false;
            
            // Physics-based movement variables
            let fishX = 100;
            let fishY = window.innerHeight / 2;
            let fishVelocityY = 0;
            let fishAccelerationY = 0;
            let fishMaxSpeed = 12; // Higher max speed for more responsive movement
            let fishAcceleration = 1.2; // Higher acceleration for quicker response
            let fishDrag = 0.92; // Slight momentum (not instant stop)
            let keysPressed = {};
            let lastMouseY = null;
            let mouseMovement = false;
            
            // Debug mode (set to true to visualize hitboxes)
            const debugMode = false;
            
            // Create background elements
            createBubbles();
            createSeaweed();
            
            function startGame() {
                resetGame();
                gameRunning = true;
                startScreen.style.display = 'none';
                
                // Create fish
                fish = document.createElement('div');
                fish.className = 'fish';
                fish.innerHTML = `
                    <svg viewBox="0 0 60 40" xmlns="http://www.w3.org/2000/svg">
                        <path d="M50,20 C45,10 35,5 20,5 C10,5 5,10 5,20 C5,30 10,35 20,35 C35,35 45,30 50,20 Z" fill="#FF9F43"/>
                        <path d="M5,20 L0,15 L0,25 Z" fill="#FF9F43"/>
                        <circle cx="40" cy="15" r="3" fill="black"/>
                        <path d="M20,15 C18,18 18,22 20,25" stroke="#FF8A43" stroke-width="2" fill="none"/>
                    </svg>
                `;
                fish.style.left = `${fishX}px`;
                fish.style.top = `${fishY}px`;
                gameContainer.appendChild(fish);
                
                // Start game loop
                gameLoop();
                
                // Add event listeners for continuous movement
                document.addEventListener('keydown', handleKeyDown);
                document.addEventListener('keyup', handleKeyUp);
                gameContainer.addEventListener('mousemove', handleMouseMove);
                gameContainer.addEventListener('click', handleClick);
                gameContainer.addEventListener('touchmove', handleTouchMove, { passive: false });
                gameContainer.addEventListener('touchstart', handleTouchStart, { passive: false });
            }
            
            function resetGame() {
                // Clear obstacles
                obstacles.forEach(obstacle => {
                    if (obstacle.element && obstacle.element.parentNode) {
                        obstacle.element.parentNode.removeChild(obstacle.element);
                    }
                });
                
                // Reset variables
                obstacles = [];
                score = 0;
                fishX = 100;
                fishY = window.innerHeight / 2;
                fishVelocityY = 0;
                fishAccelerationY = 0;
                gameSpeed = 8;
                obstacleInterval = 800;
                currentLevel = 1;
                specialAttackTimer = 0;
                keysPressed = {};
                lastMouseY = null;
                mouseMovement = false;
                scoreDisplay.textContent = `Score: ${score}`;
                
                // Remove old fish if exists
                if (fish && fish.parentNode) {
                    fish.parentNode.removeChild(fish);
                }
                
                // Hide game over screen
                gameOverScreen.style.display = 'none';
            }
            
            function gameLoop() {
                if (!gameRunning) return;
                
                // Update score
                score++;
                scoreDisplay.textContent = `Score: ${score}`;
                
                // Increase difficulty
                if (score % 300 === 0) {
                    levelUp();
                }
                
                // Special attack warning
                specialAttackTimer++;
                if (specialAttackTimer >= 500 && specialAttackTimer < 600) {
                    showWarning();
                } else if (specialAttackTimer === 600) {
                    hideWarning();
                    createSpecialAttack();
                    specialAttackTimer = 0;
                }
                
                // Create new obstacles
                const currentTime = Date.now();
                if (currentTime - lastObstacleTime > obstacleInterval) {
                    createObstacle();
                    lastObstacleTime = currentTime;
                }
                
                // Update fish physics
                updateFishMovement();
                
                // Move obstacles
                moveObstacles();
                
                // Check collisions
                if (!isInvulnerable) {
                    checkCollisions();
                }
                
                // Update debug hitboxes if debug mode is on
                if (debugMode) {
                    updateDebugHitboxes();
                }
                
                // Continue game loop
                animationId = requestAnimationFrame(gameLoop);
            }
            
            function updateFishMovement() {
                // Apply acceleration based on input
                if (keysPressed['ArrowUp'] || keysPressed['w']) {
                    fishAccelerationY = -fishAcceleration;
                } else if (keysPressed['ArrowDown'] || keysPressed['s']) {
                    fishAccelerationY = fishAcceleration;
                } else if (!mouseMovement) {
                    // Only apply drag if not using mouse/touch
                    fishAccelerationY = 0;
                    fishVelocityY *= fishDrag;
                }
                
                // Update velocity with acceleration
                fishVelocityY += fishAccelerationY;
                
                // Clamp velocity to max speed
                fishVelocityY = Math.max(-fishMaxSpeed, Math.min(fishMaxSpeed, fishVelocityY));
                
                // Update position with velocity
                fishY += fishVelocityY;
                
                // Keep fish within bounds
                if (fishY < 0) {
                    fishY = 0;
                    fishVelocityY = 0;
                } else if (fishY > window.innerHeight - 40) {
                    fishY = window.innerHeight - 40;
                    fishVelocityY = 0;
                }
                
                // Calculate rotation based on velocity (for visual effect)
                let rotation = fishVelocityY * 1.5; // Scale rotation to make it visible but not extreme
                rotation = Math.max(-20, Math.min(20, rotation)); // Limit rotation angle
                
                // Apply position and rotation to fish element
                if (fish) {
                    fish.style.transform = `translateY(0) rotate(${rotation}deg)`;
                    fish.style.top = `${fishY}px`;
                }
                
                // Reset mouse movement flag each frame
                mouseMovement = false;
            }
            
            function levelUp() {
                currentLevel++;
                gameSpeed += 0.8;
                obstacleInterval = Math.max(300, obstacleInterval - 80);
                
                // Flash the difficulty display
                const difficultyDisplay = document.getElementById('difficultyDisplay');
                difficultyDisplay.textContent = `HARD MODE - LEVEL ${currentLevel}`;
                difficultyDisplay.style.backgroundColor = 'rgba(255, 0, 0, 0.7)';
                setTimeout(() => {
                    difficultyDisplay.style.backgroundColor = 'rgba(139, 0, 0, 0.7)';
                }, 500);
            }
            
            function showWarning() {
                warningElement.style.opacity = '1';
            }
            
            function hideWarning() {
                warningElement.style.opacity = '0';
            }
            
            function createSpecialAttack() {
                // Create a school of fish or a chasing shark
                const attackType = Math.random() < 0.7 ? 'school' : 'chase';
                
                if (attackType === 'school') {
                    // Create a school of fish in a pattern
                    const patternType = Math.random() < 0.5 ? 'diagonal' : 'wave';
                    const fishCount = Math.floor(Math.random() * 5) + 5;
                    
                    if (patternType === 'diagonal') {
                        const startY = Math.random() * (window.innerHeight - 300) + 50;
                        const direction = Math.random() < 0.5 ? 1 : -1;
                        
                        for (let i = 0; i < fishCount; i++) {
                            setTimeout(() => {
                                if (!gameRunning) return;
                                
                                const y = startY + (i * 50 * direction);
                                createEnemyFish(window.innerWidth + i * 60, y, 'special');
                            }, i * 200);
                        }
                    } else {
                        const centerY = window.innerHeight / 2;
                        const amplitude = Math.random() * 100 + 50;
                        
                        for (let i = 0; i < fishCount; i++) {
                            setTimeout(() => {
                                if (!gameRunning) return;
                                
                                const phase = i * (Math.PI / 4);
                                const y = centerY + Math.sin(phase) * amplitude;
                                createEnemyFish(window.innerWidth + i * 60, y, 'special');
                            }, i * 200);
                        }
                    }
                } else {
                    // Create a chasing shark
                    const shark = document.createElement('div');
                    shark.className = 'obstacle';
                    
                    const sharkHeight = 80;
                    const sharkWidth = 120;
                    
                    shark.innerHTML = `
                        <svg width="${sharkWidth}" height="${sharkHeight}" viewBox="0 0 120 80" xmlns="http://www.w3.org/2000/svg">
                            <path d="M10,40 C20,10 50,0 90,10 C110,15 120,30 120,40 C120,50 110,65 90,70 C50,80 20,70 10,40 Z" fill="#607D8B"/>
                            <path d="M10,40 L0,30 L0,50 Z" fill="#607D8B"/>
                            <circle cx="90" cy="30" r="5" fill="black"/>
                            <path d="M60,20 C70,30 70,50 60,60" stroke="white" stroke-width="2" fill="none"/>
                            <path d="M40,0 L50,20 L60,0 Z" fill="#607D8B"/>
                            <path d="M70,80 L80,60 L90,80 Z" fill="#607D8B"/>
                        </svg>
                    `;
                    
                    shark.style.left = `${window.innerWidth}px`;
                    shark.style.top = `${fishY - sharkHeight/2}px`;
                    shark.style.width = `${sharkWidth}px`;
                    shark.style.height = `${sharkHeight}px`;
                    
                    gameContainer.appendChild(shark);
                    
                    const sharkObj = {
                        element: shark,
                        x: window.innerWidth,
                        y: fishY - sharkHeight/2,
                        width: sharkWidth,
                        height: sharkHeight,
                        type: 'shark',
                        speed: gameSpeed * 1.5,
                        targetY: fishY,
                        // Define precise hitbox for shark
                        hitbox: {
                            offsetX: 10,
                            offsetY: 15,
                            width: sharkWidth - 20,
                            height: sharkHeight - 30
                        }
                    };
                    
                    obstacles.push(sharkObj);
                }
            }
            
            function createEnemyFish(x, y, type) {
                const fishElement = document.createElement('div');
                fishElement.className = 'obstacle';
                
                const fishHeight = 30;
                const fishWidth = 50;
                
                const enemyColors = ['#E74C3C', '#9B59B6', '#3498DB', '#1ABC9C'];
                const color = enemyColors[Math.floor(Math.random() * enemyColors.length)];
                
                fishElement.innerHTML = `
                    <svg width="${fishWidth}" height="${fishHeight}" viewBox="0 0 50 30" xmlns="http://www.w3.org/2000/svg">
                        <path d="M5,15 C10,5 20,0 35,0 C45,0 50,5 50,15 C50,25 45,30 35,30 C20,30 10,25 5,15 Z" fill="${color}"/>
                        <path d="M50,15 L55,10 L55,20 Z" fill="${color}"/>
                        <circle cx="15" cy="10" r="3" fill="black"/>
                        <path d="M30,10 C32,12 32,18 30,20" stroke="white" stroke-width="1" fill="none"/>
                    </svg>
                `;
                
                fishElement.style.left = `${x}px`;
                fishElement.style.top = `${y}px`;
                fishElement.style.width = `${fishWidth}px`;
                fishElement.style.height = `${fishHeight}px`;
                
                gameContainer.appendChild(fishElement);
                
                let movementPattern = null;
                
                // Add zigzag movement for some fish
                if (Math.random() < 0.5) {
                    movementPattern = {
                        type: 'zigzag',
                        amplitude: Math.random() * 50 + 20,
                        frequency: Math.random() * 0.05 + 0.02,
                        phase: Math.random() * Math.PI * 2
                    };
                }
                
                obstacles.push({
                    element: fishElement,
                    x: x,
                    y: y,
                    width: fishWidth,
                    height: fishHeight,
                    type: type || 'fish',
                    speed: gameSpeed * 1.2,
                    movementPattern: movementPattern,
                    initialY: y,
                    time: 0,
                    // Define precise hitbox for enemy fish
                    hitbox: {
                        offsetX: 10,
                        offsetY: 5,
                        width: fishWidth - 15,
                        height: fishHeight - 10
                    }
                });
            }
            
            function createObstacle() {
                const obstacleTypes = ['fish', 'jellyfish', 'pufferfish', 'seahorse'];
                const weights = [0.4, 0.3, 0.2, 0.1];
                
                // Weighted random selection
                let random = Math.random();
                let obstacleType;
                let sum = 0;
                
                for (let i = 0; i < weights.length; i++) {
                    sum += weights[i];
                    if (random <= sum) {
                        obstacleType = obstacleTypes[i];
                        break;
                    }
                }
                
                const obstacleElement = document.createElement('div');
                obstacleElement.className = 'obstacle';
                
                const height = window.innerHeight;
                let obstacleY, obstacleHeight, obstacleWidth;
                let speed = gameSpeed;
                let movementPattern = null;
                let hitbox = {};
                
                switch (obstacleType) {
                    case 'fish':
                        obstacleHeight = 30;
                        obstacleWidth = 50;
                        obstacleY = Math.random() * (height - 150) + 50;
                        speed = gameSpeed * 1.2;
                        
                        const enemyColors = ['#E74C3C', '#9B59B6', '#3498DB', '#1ABC9C'];
                        const color = enemyColors[Math.floor(Math.random() * enemyColors.length)];
                        
                        obstacleElement.innerHTML = `
                            <svg width="${obstacleWidth}" height="${obstacleHeight}" viewBox="0 0 50 30" xmlns="http://www.w3.org/2000/svg">
                                <path d="M5,15 C10,5 20,0 35,0 C45,0 50,5 50,15 C50,25 45,30 35,30 C20,30 10,25 5,15 Z" fill="${color}"/>
                                <path d="M50,15 L55,10 L55,20 Z" fill="${color}"/>
                                <circle cx="15" cy="10" r="3" fill="black"/>
                                <path d="M30,10 C32,12 32,18 30,20" stroke="white" stroke-width="1" fill="none"/>
                            </svg>
                        `;
                        
                        // Define precise hitbox for fish
                        hitbox = {
                            offsetX: 10,
                            offsetY: 5,
                            width: obstacleWidth - 15,
                            height: obstacleHeight - 10
                        };
                        
                        // Add zigzag movement for some fish
                        if (Math.random() < 0.5) {
                            movementPattern = {
                                type: 'zigzag',
                                amplitude: Math.random() * 50 + 20,
                                frequency: Math.random() * 0.05 + 0.02,
                                phase: Math.random() * Math.PI * 2
                            };
                        }
                        break;
                        
                    case 'jellyfish':
                        obstacleHeight = 60;
                        obstacleWidth = 40;
                        obstacleY = Math.random() * (height - 150) + 50;
                        
                        obstacleElement.innerHTML = `
                            <svg width="${obstacleWidth}" height="${obstacleHeight}" viewBox="0 0 40 60" xmlns="http://www.w3.org/2000/svg">
                                <path d="M5,10 Q20,-5 35,10 Q40,30 35,40 Q30,50 25,60 Q20,50 15,60 Q10,50 5,40 Q0,30 5,10 Z" fill="#9C27B0" fill-opacity="0.7"/>
                                <path d="M20,40 Q15,50 10,60 M20,40 Q25,50 30,60" stroke="#9C27B0" stroke-width="2" fill="none"/>
                            </svg>
                        `;
                        
                        // Define precise hitbox for jellyfish
                        hitbox = {
                            offsetX: 5,
                            offsetY: 10,
                            width: obstacleWidth - 10,
                            height: obstacleHeight - 20
                        };
                        
                        // Add floating movement
                        movementPattern = {
                            type: 'float',
                            amplitude: 30,
                            frequency: 0.03,
                            phase: Math.random() * Math.PI * 2
                        };
                        break;
                        
                    case 'pufferfish':
                        obstacleHeight = 50;
                        obstacleWidth = 50;
                        obstacleY = Math.random() * (height - 150) + 50;
                        
                        obstacleElement.innerHTML = `
                            <svg width="${obstacleWidth}" height="${obstacleHeight}" viewBox="0 0 50 50" xmlns="http://www.w3.org/2000/svg">
                                <circle cx="25" cy="25" r="20" fill="#FFC107"/>
                                <path d="M25,5 L25,0 M25,45 L25,50 M5,25 L0,25 M45,25 L50,25 M10,10 L5,5 M40,10 L45,5 M10,40 L5,45 M40,40 L45,45" stroke="#FFC107" stroke-width="2"/>
                                <circle cx="18" cy="20" r="3" fill="black"/>
                                <circle cx="32" cy="20" r="3" fill="black"/>
                                <path d="M20,30 Q25,35 30,30" stroke="black" stroke-width="2" fill="none"/>
                            </svg>
                        `;
                        
                        // Define precise hitbox for pufferfish (circular)
                        hitbox = {
                            offsetX: 5,
                            offsetY: 5,
                            width: obstacleWidth - 10,
                            height: obstacleHeight - 10,
                            isCircle: true
                        };
                        
                        // Pufferfish moves slower but is bigger
                        speed = gameSpeed * 0.8;
                        break;
                        
                    case 'seahorse':
                        obstacleHeight = 70;
                        obstacleWidth = 40;
                        obstacleY = Math.random() * (height - 150) + 50;
                        
                        obstacleElement.innerHTML = `
                            <svg width="${obstacleWidth}" height="${obstacleHeight}" viewBox="0 0 40 70" xmlns="http://www.w3.org/2000/svg">
                                <path d="M30,10 C35,15 35,25 30,30 C25,35 25,45 30,50 C35,55 35,65 30,70 C25,65 20,60 15,55 C10,50 5,45 5,40 C5,35 10,30 15,25 C20,20 25,15 20,10 C15,5 20,0 25,0 C30,0 35,5 30,10 Z" fill="#26A69A"/>
                                <circle cx="28" cy="8" r="2" fill="black"/>
                                <path d="M15,40 C10,40 5,35 5,30" stroke="#26A69A" stroke-width="2" fill="none"/>
                            </svg>
                        `;
                        
                        // Define precise hitbox for seahorse
                        hitbox = {
                            offsetX: 5,
                            offsetY: 5,
                            width: obstacleWidth - 15,
                            height: obstacleHeight - 10
                        };
                        
                        // Seahorse moves in a wavy pattern
                        movementPattern = {
                            type: 'float',
                            amplitude: 20,
                            frequency: 0.04,
                            phase: Math.random() * Math.PI * 2
                        };
                        break;
                }
                
                obstacleElement.style.left = `${window.innerWidth}px`;
                obstacleElement.style.top = `${obstacleY}px`;
                obstacleElement.style.width = `${obstacleWidth}px`;
                obstacleElement.style.height = `${obstacleHeight}px`;
                
                gameContainer.appendChild(obstacleElement);
                
                obstacles.push({
                    element: obstacleElement,
                    x: window.innerWidth,
                    y: obstacleY,
                    width: obstacleWidth,
                    height: obstacleHeight,
                    type: obstacleType,
                    speed: speed,
                    movementPattern: movementPattern,
                    initialY: obstacleY,
                    time: 0,
                    hitbox: hitbox
                });
            }
            
            function moveObstacles() {
                for (let i = obstacles.length - 1; i >= 0; i--) {
                    const obstacle = obstacles[i];
                    
                    // Update time for movement patterns
                    obstacle.time += 0.016; // Approximately 60fps
                    
                    // Move obstacle based on its speed
                    obstacle.x -= obstacle.speed || gameSpeed;
                    
                    // Apply movement patterns
                    if (obstacle.movementPattern) {
                        switch (obstacle.movementPattern.type) {
                            case 'zigzag':
                                obstacle.y = obstacle.initialY + 
                                    Math.sin(obstacle.time * obstacle.movementPattern.frequency * Math.PI * 2 + 
                                            obstacle.movementPattern.phase) * 
                                    obstacle.movementPattern.amplitude;
                                break;
                                
                            case 'float':
                                obstacle.y = obstacle.initialY + 
                                    Math.sin(obstacle.time * obstacle.movementPattern.frequency * Math.PI * 2 + 
                                            obstacle.movementPattern.phase) * 
                                    obstacle.movementPattern.amplitude;
                                break;
                        }
                    }
                    
                    // Special behavior for shark
                    if (obstacle.type === 'shark') {
                        // Update target position to follow the fish
                        obstacle.targetY = fishY - obstacle.height/2 + 20;
                        
                        // Move towards the target
                        const dy = obstacle.targetY - obstacle.y;
                        obstacle.y += dy * 0.05;
                    }
                    
                    if (obstacle.x < -obstacle.width) {
                        // Remove obstacle that's off screen
                        gameContainer.removeChild(obstacle.element);
                        obstacles.splice(i, 1);
                    } else {
                        // Update position
                        obstacle.element.style.left = `${obstacle.x}px`;
                        obstacle.element.style.top = `${obstacle.y}px`;
                    }
                }
            }
            
            function checkCollisions() {
                if (!fish) return;
                
                // Define player fish hitbox (more precise than the full sprite)
                const fishHitbox = {
                    x: fishX + 10, // Offset from left edge of sprite
                    y: fishY + 5,  // Offset from top edge of sprite
                    width: 40,     // Smaller than full width (60px)
                    height: 30     // Smaller than full height (40px)
                };
                
                // Check for obstacle collisions with precise hitboxes
                for (const obstacle of obstacles) {
                    // Calculate obstacle's precise hitbox
                    const obstacleHitbox = {
                        x: obstacle.x + (obstacle.hitbox?.offsetX || 0),
                        y: obstacle.y + (obstacle.hitbox?.offsetY || 0),
                        width: obstacle.hitbox?.width || obstacle.width,
                        height: obstacle.hitbox?.height || obstacle.height
                    };
                    
                    let collision = false;
                    
                    if (obstacle.hitbox?.isCircle) {
                        // For circular hitboxes (like pufferfish)
                        const circleX = obstacleHitbox.x + obstacleHitbox.width / 2;
                        const circleY = obstacleHitbox.y + obstacleHitbox.height / 2;
                        const radius = obstacleHitbox.width / 2;
                        
                        // Calculate closest point on rectangle to circle center
                        const closestX = Math.max(fishHitbox.x, Math.min(circleX, fishHitbox.x + fishHitbox.width));
                        const closestY = Math.max(fishHitbox.y, Math.min(circleY, fishHitbox.y + fishHitbox.height));
                        
                        // Calculate distance between closest point and circle center
                        const distanceX = circleX - closestX;
                        const distanceY = circleY - closestY;
                        const distanceSquared = distanceX * distanceX + distanceY * distanceY;
                        
                        // Check if distance is less than radius
                        collision = distanceSquared < (radius * radius);
                    } else {
                        // For rectangular hitboxes
                        collision = (
                            fishHitbox.x < obstacleHitbox.x + obstacleHitbox.width &&
                            fishHitbox.x + fishHitbox.width > obstacleHitbox.x &&
                            fishHitbox.y < obstacleHitbox.y + obstacleHitbox.height &&
                            fishHitbox.y + fishHitbox.height > obstacleHitbox.y
                        );
                    }
                    
                    if (collision) {
                        gameOver();
                        return;
                    }
                }
            }
            
            // Update debug hitboxes if debug mode is on
            function updateDebugHitboxes() {
                // Show debug hitboxes if debug mode is on
                if (debugMode) {
                    fishHitboxElement.style.display = 'block';
                    fishHitboxElement.style.left = `${fishX + 10}px`;
                    fishHitboxElement.style.top = `${fishY + 5}px`;
                    fishHitboxElement.style.width = `${40}px`;
                    fishHitboxElement.style.height = `${30}px`;
                    
                    // Remove old obstacle hitboxes
                    document.querySelectorAll('.obstacle-hitbox').forEach(el => el.remove());
                    
                    // Create obstacle hitboxes
                    obstacles.forEach((obstacle, index) => {
                        let hitboxEl = document.getElementById(`obstacle-hitbox-${index}`);
                        if (!hitboxEl) {
                            hitboxEl = document.createElement('div');
                            hitboxEl.id = `obstacle-hitbox-${index}`;
                            hitboxEl.className = 'hitbox obstacle-hitbox';
                            gameContainer.appendChild(hitboxEl);
                        }
                        
                        const hitbox = obstacle.hitbox || {};
                        const x = obstacle.x + (hitbox.offsetX || 0);
                        const y = obstacle.y + (hitbox.offsetY || 0);
                        const width = hitbox.width || obstacle.width;
                        const height = hitbox.height || obstacle.height;
                        
                        hitboxEl.style.display = 'block';
                        hitboxEl.style.left = `${x}px`;
                        hitboxEl.style.top = `${y}px`;
                        hitboxEl.style.width = `${width}px`;
                        hitboxEl.style.height = `${height}px`;
                        
                        if (hitbox.isCircle) {
                            hitboxEl.style.borderRadius = '50%';
                        } else {
                            hitboxEl.style.borderRadius = '0';
                        }
                    });
                }
            }
            
            function gameOver() {
                gameRunning = false;
                cancelAnimationFrame(animationId);
                
                // Remove all event listeners
                document.removeEventListener('keydown', handleKeyDown);
                document.removeEventListener('keyup', handleKeyUp);
                gameContainer.removeEventListener('mousemove', handleMouseMove);
                gameContainer.removeEventListener('click', handleClick);
                gameContainer.removeEventListener('touchmove', handleTouchMove);
                gameContainer.removeEventListener('touchstart', handleTouchStart);
                
                finalScoreDisplay.textContent = score;
                gameOverScreen.style.display = 'block';
            }
            
            // Continuous keyboard movement
            function handleKeyDown(e) {
                keysPressed[e.key] = true;
            }
            
            function handleKeyUp(e) {
                keysPressed[e.key] = false;
            }
            
            // Mouse movement for more precise control
            function handleMouseMove(e) {
                if (!lastMouseY) {
                    lastMouseY = e.clientY;
                    return;
                }
                
                // Calculate mouse movement speed
                const mouseSpeed = (e.clientY - lastMouseY) * 0.8; // Sensitivity multiplier
                
                // Apply direct velocity change based on mouse movement
                fishVelocityY = mouseSpeed;
                
                // Set flag to indicate we're using mouse control
                mouseMovement = true;
                
                // Update last position
                lastMouseY = e.clientY;
            }
            
            function handleClick(e) {
                // Determine direction based on click position
                const targetY = e.clientY;
                
                // Apply immediate velocity change toward click point
                const distance = targetY - fishY;
                fishVelocityY = Math.sign(distance) * Math.min(Math.abs(distance) * 0.2, fishMaxSpeed);
                
                // Set flag to indicate we're using mouse control
                mouseMovement = true;
            }
            
            // Touch controls
            function handleTouchMove(e) {
                e.preventDefault();
                
                if (!lastMouseY) {
                    lastMouseY = e.touches[0].clientY;
                    return;
                }
                
                // Calculate touch movement speed
                const touchSpeed = (e.touches[0].clientY - lastMouseY) * 0.8; // Sensitivity multiplier
                
                // Apply direct velocity change based on touch movement
                fishVelocityY = touchSpeed;
                
                // Set flag to indicate we're using touch control
                mouseMovement = true;
                
                // Update last position
                lastMouseY = e.touches[0].clientY;
            }
            
            function handleTouchStart(e) {
                e.preventDefault();
                lastMouseY = e.touches[0].clientY;
                
                // For single taps, move toward the touch point
                const targetY = e.touches[0].clientY;
                const distance = targetY - fishY;
                fishVelocityY = Math.sign(distance) * Math.min(Math.abs(distance) * 0.2, fishMaxSpeed);
                
                // Set flag to indicate we're using touch control
                mouseMovement = true;
            }
            
            function createBubbles() {
                const bubbleCount = 20;
                
                for (let i = 0; i < bubbleCount; i++) {
                    const bubble = document.createElement('div');
                    bubble.className = 'bubble';
                    
                    const size = Math.random() * 20 + 5;
                    const x = Math.random() * window.innerWidth;
                    const y = Math.random() * window.innerHeight;
                    
                    bubble.style.width = `${size}px`;
                    bubble.style.height = `${size}px`;
                    bubble.style.left = `${x}px`;
                    bubble.style.top = `${y}px`;
                    bubble.style.animationDelay = `${Math.random() * 5}s`;
                    
                    gameContainer.appendChild(bubble);
                }
            }
            
            function createSeaweed() {
                const seaweedCount = 8;
                
                for (let i = 0; i < seaweedCount; i++) {
                    const seaweed = document.createElement('div');
                    seaweed.className = 'seaweed';
                    
                    const height = Math.random() * 100 + 50;
                    const x = (window.innerWidth / (seaweedCount - 1)) * i;
                    
                    seaweed.innerHTML = `
                        <svg width="30" height="${height}" viewBox="0 0 30 ${height}" xmlns="http://www.w3.org/2000/svg">
                            <path d="M15,0 C10,${height*0.3} 20,${height*0.5} 15,${height} M5,0 C0,${height*0.4} 10,${height*0.6} 5,${height} M25,0 C20,${height*0.2} 30,${height*0.7} 25,${height}" 
                                stroke="#0a5c36" stroke-width="3" fill="none"/>
                        </svg>
                    `;
                    
                    seaweed.style.left = `${x}px`;
                    
                    gameContainer.appendChild(seaweed);
                }
            }
            
            // Event listeners for buttons
            startButton.addEventListener('click', startGame);
            restartButton.addEventListener('click', startGame);
            
            // Make game responsive
            window.addEventListener('resize', () => {
                if (fish) {
                    fishY = Math.min(fishY, window.innerHeight - 40);
                    fish.style.top = `${fishY}px`;
                }
            });
        });
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'94a86fe971f479d9',t:'MTc0OTA1MDY2Ni4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script><iframe height="1" width="1" style="position: absolute; top: 0px; left: 0px; border: medium; visibility: hidden;"></iframe>

</body></html>